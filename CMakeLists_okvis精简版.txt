#精简版的okvis默认是你已经安装了ceres
cmake_minimum_required(VERSION 2.8.11)

project(okvis)
# The version number.
set(OKVIS_MAJOR_VERSION 1)
set(OKVIS_MINOR_VERSION 1)
set(OKVIS_PATCH_VERSION 3)
set(OKVIS_VERSION  ${OKVIS_MAJOR_VERSION}.${OKVIS_MINOR_VERSION}.${OKVIS_PATCH_VERSION})

# options for build configuration
#设定编译的参数
option (BUILD_APPS "Builds a demo app (which requires boost)" ON) 

#设置变量N_CORES的值为3
SET(N_CORES 3 CACHE STRING "Using N number of cores for parallel build")

# Offer the user the choice of overriding the installation directories
#INSTALL_LIB_DIR、INSTALL_BIN_DIR和INSTALL_INCLUDE_DIR都是作者自己定义的变量
set(INSTALL_LIB_DIR lib CACHE PATH "Installation directory for libraries")
set(INSTALL_BIN_DIR bin CACHE PATH "Installation directory for executables")
set(INSTALL_INCLUDE_DIR include CACHE PATH  "Installation directory for header files")
if(WIN32 AND NOT CYGWIN)
  set(DEF_INSTALL_CMAKE_DIR CMake)
else()#linux下默认进入这个条件，DEF_INSTALL_CMAKE_DIR作者自己定义的变量
  set(DEF_INSTALL_CMAKE_DIR lib/CMake/okvis)
endif()
set(INSTALL_CMAKE_DIR ${DEF_INSTALL_CMAKE_DIR} CACHE PATH  "Installation directory for CMake files")
 
# Make relative paths absolute (needed later on)
foreach(p LIB BIN INCLUDE CMAKE)
  set(var INSTALL_${p}_DIR)
  if(NOT IS_ABSOLUTE "${${var}}")
    set(${var} "${CMAKE_INSTALL_PREFIX}/${${var}}")
  endif()
endforeach()

# make sure we use Release and warn otherwise
#CMAKE_BUILD_TYPE是cmake的变量 可以设置为"Debug"和"Release"
#我感觉默认应该是不进入这个条件的
if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
  message(STATUS "Setting build type to 'Release' as none was specified.")
  set(CMAKE_BUILD_TYPE Release CACHE STRING "Choose the type of build." FORCE)
  # Set the possible values of build type for cmake-gui
  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS "Debug" "Release"
    "MinSizeRel" "RelWithDebInfo")
endif()

if (NOT "${CMAKE_BUILD_TYPE}" STREQUAL "Release")
  message(WARNING "CMAKE_BUILD_TYPE not set to 'Release'. Performance may be terrible.")
else()
  message(STATUS "Building with build type '${CMAKE_BUILD_TYPE}'")
endif()

#APPLE是cmake的变量，表示是否为苹果操作系统，一般不会进入这个条件
if(APPLE)
  # The clang compiler (on osx) is somehow much more strict
  # than the compilers on ubuntu and so this does not seem
  # possible on OSX just yet.
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -march=native -Wall -std=c++11 -fPIC")
else()
   #设置c++的编译选项
   #-wall：打开警告开关。-march=native：gcc-4.2以上版本支持 gcc会自动选择最适合cpu的优化
   #告诉编译器产生与位置无关代码(Position-Independent Code)，则产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意位置，都可以正确的执行。
   #这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -march=native -Wall -std=c++11 -fPIC")
endif()

#CMAKE_HOST_SYSTEM_PROCESSOR也是cmake的变量，表示当前的cmake运行在什么cpu上，
if(${CMAKE_HOST_SYSTEM_PROCESSOR} MATCHES "arm*")#一般不会进入这个条件
  message(STATUS "ARM processor detected, will attempt to use NEON.")
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mfpu=neon")
else()
  message(STATUS "Assuming SSE instructions available.")
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mssse3")
endif()

#并没有用到defs
get_directory_property(defs COMPILE_DEFINITIONS)

# EXTERNAL DEPENDENCIES
#ExternalProject是cmake定义的变量，有些库我们自己的系统中没有安装需要从互联网下载编译之后使用，这个ExternalProject就是用于从互联网上下载后的库
include(ExternalProject)
#添加${PROJECT_SOURCE_DIR}/cmake_modules元素到CMAKE_MODULE_PATH列表中
#一般来说，都是这样用 cmake ./这样当前目录和PROJECT_SOURCE_DIR是等价的。也就是当前源码的目录。
#如果执行cmake的时候，并不在源码的路径的话，比如cmake ../src。此时PROJECT_SOURCE_DIR目录就是../src
list(APPEND CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/cmake")
# CMAKE_BINARY_DIR是cmake的变量，一般情况下等于PROJECT_SOURCE_DIR
include_directories(${CMAKE_BINARY_DIR}/include)
link_directories(${CMAKE_BINARY_DIR}/lib)#加入非标准的库文件搜索路径

# require Eigen
find_package( Eigen REQUIRED )
include_directories(${EIGEN_INCLUDE_DIR}) 

# libvisensor正常情况下 我们没有安装这个库
find_package(VISensor)

if(VISENSORDRIVER_FOUND)
  add_definitions(-DHAVE_LIBVISENSOR)
  set(LIBVISENSOR TRUE)
  message(STATUS "Found libvisensor. Setting HAVE_LIBVISENSOR flag.")
  include_directories(${VISensorDriver_INCLUDE_DIR})
  # install find script
  install(FILES ${PROJECT_SOURCE_DIR}/cmake/FindVISensor.cmake
    DESTINATION ${CMAKE_INSTALL_PREFIX}/lib/CMake)
else()
  message(STATUS "libvisensor not found")
endif()



# glog
find_package(Glog REQUIRED)
include_directories(BEFORE ${GLOG_INCLUDE_DIRS}) 

# brisk 下载并安装brisk
  ExternalProject_Add(brisk_external
    URL "https://www.doc.ic.ac.uk/~sleutene/software/brisk-2.0.3.zip"    
    INSTALL_DIR ${CMAKE_BINARY_DIR}
    CMAKE_ARGS -DCMAKE_INSTALL_PREFIX:PATH=<INSTALL_DIR> -DCMAKE_BUILD_TYPE:STRING=${CMAKE_BUILD_TYPE}
    PREFIX ${CMAKE_CURRENT_BINARY_DIR}/brisk
    BUILD_IN_SOURCE 0
    BUILD_COMMAND make -j${N_CORES}
    INSTALL_COMMAND make install
  )
  add_library(brisk STATIC IMPORTED)
  add_library(agast STATIC IMPORTED)
  set(BRISK_LIBRARIES brisk agast)
  set_target_properties(brisk PROPERTIES IMPORTED_LOCATION ${CMAKE_BINARY_DIR}/lib/libbrisk.a)
  set_target_properties(agast PROPERTIES IMPORTED_LOCATION ${CMAKE_BINARY_DIR}/lib/libagast.a)
  add_dependencies(brisk brisk_external)
  add_dependencies(agast brisk_external)

  # install it once built
  install(FILES ${CMAKE_BINARY_DIR}/lib/libbrisk.a ${CMAKE_BINARY_DIR}/lib/libagast.a 
    DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)
  install(DIRECTORY ${CMAKE_BINARY_DIR}/include/brisk/ 
    DESTINATION ${CMAKE_INSTALL_PREFIX}/include/brisk/)
  install(DIRECTORY ${CMAKE_BINARY_DIR}/lib/CMake/brisk/
    DESTINATION ${CMAKE_INSTALL_PREFIX}/lib/CMake/brisk/)



find_package(SuiteSparse REQUIRED QUIET) #will be needed in any case...
find_package(CXSparse QUIET) #optional

 # ceres
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake")
 find_package( Ceres 1.9 REQUIRED )
 #将给定目录加给编译器搜索到的包含文件 .默认情况下，加到目录列表的最后,如果是before则加在列表的最前面
 include_directories(BEFORE ${CERES_INCLUDE_DIRS})
 message(STATUS "Using system Ceres.")

# OpenGV 这个是比较重要的一步！！！！！！！！！！！！！！需要下载库并安装编译
#OpenGV is a collection of computer vision methods for solving geometric vision problems. 
set(CMAKE_CXX_FLAGS_WSUPPRESS 
      "${CMAKE_CXX_FLAGS} -Wno-unused-parameter -Wno-maybe-uninitialized -Wno-sign-compare -Wno-unused-but-set-variable -Wno-unused-variable -Wno-pedantic")
message(STATUS "NOTE: Suppressing some warnings when compiling OpenGV.")
ExternalProject_Add(opengv_external
    GIT_REPOSITORY https://github.com/laurentkneip/opengv
    GIT_TAG cc32b16281aa6eab67cb28a61cf87a2a5c2b0961
    UPDATE_COMMAND ""
    PATCH_COMMAND # forcing static libs
        COMMAND ${CMAKE_COMMAND} -E copy ${PROJECT_SOURCE_DIR}/cmake/opengv/CMakeLists.txt ${CMAKE_CURRENT_BINARY_DIR}/opengv/src/opengv/CMakeLists.txt
        COMMAND ${CMAKE_COMMAND} -E copy ${PROJECT_SOURCE_DIR}/cmake/opengv/opengvConfig.cmake.in ${CMAKE_CURRENT_BINARY_DIR}/opengv/src/opengv/opengvConfig.cmake.in
        COMMENT "Forcing our own CMakeLists.txt to build OpenGV (static library support)."
    CMAKE_ARGS 
      -DCMAKE_INSTALL_PREFIX:PATH=<INSTALL_DIR> 
      -DCMAKE_BUILD_TYPE:STRING=${CMAKE_BUILD_TYPE} 
      -DCMAKE_CXX_FLAGS=${CMAKE_CXX_FLAGS_WSUPPRESS} # suppress warnings...
    PREFIX ${CMAKE_CURRENT_BINARY_DIR}/opengv
    SOURCE_DIR ${CMAKE_CURRENT_BINARY_DIR}/opengv/src/opengv
    INSTALL_DIR ${CMAKE_BINARY_DIR}
    BUILD_IN_SOURCE 0
    BUILD_COMMAND make -j${N_CORES}
    INSTALL_COMMAND make install
)
#将源文件加入到lib${PROJECT_NAME}.so库中，此处加入的库就是opengv.so的链接库。这个库由如下的源文件组成
#SHARED表示动态链接库，STATIC表示静态库。
add_library(opengv STATIC IMPORTED)
set(OpenGV_LIBRARIES opengv)
set_target_properties(opengv PROPERTIES IMPORTED_LOCATION ${CMAKE_BINARY_DIR}/lib/libopengv.a)
add_dependencies(${OpenGV_LIBRARIES} opengv_external)#定义target依赖的其他target，确保在编译本target之前，其他的target已经被构建。

# install it once built
#FILES表示安装的是文件，DIRECTORY表示安装的是目录即将整个目录的内容安装到目的地址中
#DESTINATION表示安装的目的地址
install(FILES ${CMAKE_BINARY_DIR}/lib/libopengv.a 
  DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)
install(DIRECTORY ${CMAKE_BINARY_DIR}/include/opengv/ 
  DESTINATION ${CMAKE_INSTALL_PREFIX}/include/opengv/)
install(DIRECTORY ${CMAKE_BINARY_DIR}/lib/CMake/opengv/
  DESTINATION ${CMAKE_INSTALL_PREFIX}/lib/CMake/opengv/)



# BUILD LOCAL DEPENDENCIES
include_directories(okvis_util/include)
#okvis_util目录下的CMakeLists.txt文件和源代码会被执行。 
add_subdirectory(okvis_util)

include_directories(okvis_kinematics/include)
add_subdirectory(okvis_kinematics)
add_dependencies(okvis_kinematics okvis_util)

include_directories(okvis_time/include)
add_subdirectory(okvis_time)
add_dependencies(okvis_time okvis_util)

include_directories(okvis_cv/include)
add_subdirectory(okvis_cv)
add_dependencies(okvis_cv brisk okvis_util)

include_directories(okvis_common/include)
add_subdirectory(okvis_common)

include_directories(okvis_ceres/include)
add_subdirectory(okvis_ceres)
add_dependencies(okvis_ceres ceres okvis_util)

include_directories(okvis_timing/include)
add_subdirectory(okvis_timing)

include_directories(okvis_matcher/include)
add_subdirectory(okvis_matcher)
add_dependencies(okvis_matcher okvis_util)

include_directories(okvis_frontend/include)
add_subdirectory(okvis_frontend)
add_dependencies(okvis_frontend opengv okvis_util)

include_directories(okvis_multisensor_processing/include)
add_subdirectory(okvis_multisensor_processing)
add_dependencies(okvis_multisensor_processing okvis_util)

# also build the apps
#默认是进入这个条件的
if(BUILD_APPS)
  FIND_PACKAGE(Boost COMPONENTS filesystem system REQUIRED)
  include_directories(${Boost_INCLUDE_DIRS}) 
  add_executable(okvis_app_synchronous okvis_apps/src/okvis_app_synchronous.cpp)#生成一个名为okvis_app_synchronous的可执行文件，需要okvis_app_synchronous.cpp源文件。
  target_link_libraries(okvis_app_synchronous 
    okvis_util
    okvis_kinematics
    okvis_time
    okvis_cv 
    okvis_common
    okvis_ceres
    okvis_timing
    okvis_matcher
    okvis_frontend 
    okvis_multisensor_processing
    pthread 
    ${Boost_LIBRARIES}
  )
  if(${VISENSORDRIVER_FOUND})#默认我们是没有安装这个库的
    target_link_libraries(okvis_app_synchronous ${VISensorDriver_LIBRARY})
  endif()
  #安装目标类型文件 分为三种ARCHIVE特指静态库，LIBRARY特指动态库，RUNTIME特指可执行目标二进制。
  install(TARGETS okvis_app_synchronous
    # IMPORTANT: Add the executable to the "export-set"
    EXPORT okvisTargets
    RUNTIME DESTINATION "${INSTALL_BIN_DIR}" COMPONENT bin)
endif()

# installation is invoked in the individual modules...
#创建一个名为"${PROJECT_BINARY_DIR}/okvisTargets.cmake"的文件从而外部工程可以从当前工程的构建树中导入目标。
export (TARGETS 
    okvis_app_synchronous
    okvis_util
    okvis_kinematics
    okvis_time
    okvis_cv 
    okvis_common
    okvis_ceres
    okvis_timing
    okvis_matcher
    okvis_frontend 
    okvis_multisensor_processing 
    FILE "${PROJECT_BINARY_DIR}/okvisTargets.cmake")
export ( PACKAGE okvis )

# Create the okvisConfig.cmake and okvisConfigVersion files
file(RELATIVE_PATH REL_INCLUDE_DIR "${INSTALL_CMAKE_DIR}" "${INSTALL_INCLUDE_DIR}")
# ... for the build tree
set(CONF_INCLUDE_DIRS 
  "${PROJECT_SOURCE_DIR}/okvis_util/include"
  "${PROJECT_SOURCE_DIR}/okvis_kinematics/include"
  "${PROJECT_SOURCE_DIR}/okvis_time/include"
  "${PROJECT_SOURCE_DIR}/okvis_cv/include"
  "${PROJECT_SOURCE_DIR}/okvis_common/include"
  "${PROJECT_SOURCE_DIR}/okvis_ceres/include"
  "${PROJECT_SOURCE_DIR}/okvis_timing/include"
  "${PROJECT_SOURCE_DIR}/okvis_matcher/include"
  "${PROJECT_SOURCE_DIR}/okvis_frontend/include"
  "${PROJECT_SOURCE_DIR}/okvis_multisensor_processing/include"
  "${PROJECT_BINARY_DIR}"
)
#configure_file 的作用是让普通文件也能使用CMake中的变量。
configure_file(cmake/okvisConfig.cmake.in "${PROJECT_BINARY_DIR}/okvisConfig.cmake" @ONLY)
# ... for the install tree
set(CONF_INCLUDE_DIRS "\${OKVIS_CMAKE_DIR}/${REL_INCLUDE_DIR}")
configure_file(cmake/okvisConfig.cmake.in
  "${PROJECT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/okvisConfig.cmake" @ONLY)
# ... for both
configure_file(cmake/okvisConfigVersion.cmake.in
  "${PROJECT_BINARY_DIR}/okvisConfigVersion.cmake" @ONLY)
 
# Install the okvisConfig.cmake and okvisConfigVersion.cmake
install(FILES
  "${PROJECT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/okvisConfig.cmake"
  "${PROJECT_BINARY_DIR}/okvisConfigVersion.cmake"
  DESTINATION "${INSTALL_CMAKE_DIR}")
 
# Install the export set for use with the install-tree
install(EXPORT okvisTargets DESTINATION
  "${INSTALL_CMAKE_DIR}")
